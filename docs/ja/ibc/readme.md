# 概要

IBC、そのコンポーネント、およびIBCのユースケースについて学習します。 {synopsis}

## ブロックチェーン間通信プロトコル(IBC)とは何ですか？

このドキュメントは、独自のブロック間チェーンを作成したい開発者向けのガイドとして役立ちます
カスタムユースケース向けの通信プロトコル(IBC)アプリケーション。

> IBCアプリケーションは、自己完結型のモジュールとして作成する必要があります。

IBCプロトコルのモジュラー設計により、IBC
アプリケーション開発者は、クライアントの低レベルの詳細を気にする必要はありません。
接続、および証明の検証。

の下位レベルのこの簡単な説明
スタックは、アプリケーション開発者にIBCの幅広い理解を提供します
プロトコル。チャネルとポートの抽象化レイヤーの詳細は、アプリケーション開発者にとって最も関連性があり、カスタムパケットと `IBCModule`コールバックを定義する方法を説明しています。

モジュールがIBCを介して相互作用するための要件は次のとおりです。

-1つまたは複数のポートにバインドします。
-パケットデータを定義します。
-コアIBCが提供するデフォルトの確認応答構造体を使用するか、オプションでカスタム確認応答構造体を定義します。
-パケットデータのエンコーディングを標準化します。
-`IBCModule`インターフェースを実装します。

自己完結型のIBCアプリケーションモジュールを作成する方法の詳細な説明については、以下をお読みください。

## コンポーネントの概要

### [Clients](https://github.com/cosmos/ibc-go/blob/main/modules/core/02-client)

IBCクライアントはオンチェーンライトクライアントです。各ライトクライアントは、一意のクライアントIDによって識別されます。
IBCクライアントは、他のブロックチェーンのコンセンサス状態を、
クライアントのコンセンサス状態に対して証明を適切に検証します。クライアントは任意の番号に関連付けることができます
カウンターパーティチェーンへの接続の。クライアント識別子は、クライアントタイプを使用して自動生成されます
そして、グローバルクライアントカウンターは、 `{client-type}-{N}`の形式で追加されます。

`ClientState`には、更新の検証に必要なチェーン固有のライトクライアント固有の情報が含まれている必要があります
IBCクライアントにアップグレードします。 `ClientState`には、チェーンID、最新の高さ、証明仕様などの情報が含まれる場合があります。
ボンディング解除期間またはライトクライアントのステータス。 `ClientState`には、次のような情報を含めることはできません。
特定の高さの特定のブロックに固有であり、これは `CosnensusState`の関数です。各 `ConsensusState`
一意のブロックに関連付ける必要があり、高さを使用して参照する必要があります。 IBCクライアントには
関連するクライアント状態とコンセンサス状態を一緒に保存するためのクライアント識別子プレフィックス付きストア
コンセンサス状態に関連付けられたメタデータ。コンセンサス状態は、関連する高さを使用して保存されます。

サポートされているIBCクライアントは次のとおりです。

* [Solo Machineライトクライアント](https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/06-solomachine):電話、ブラウザー、ラップトップなどのデバイス。
* [Tendermintライトクライアント](https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/07-tendermint):CosmosSDKベースのチェーンのデフォルト。
* [ローカルホスト(ループバック)クライアント](https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/09-localhost):次の場合に便利です
テスト、シミュレーション、および同じアプリケーション上のモジュールへのパケットの中継。

### IBCクライアントの高さ

IBCクライアントの高さは構造体で表されます。

```go
type Height struct {
   RevisionNumber uint64
   RevisionHeight uint64
}
```

`RevisionNumber`は、高さが表すチェーンのリビジョンを表します。
リビジョンは通常、連続的で単調に増加するブロック高さの範囲を表します。
`RevisionHeight`は、指定されたリビジョン内のチェーンの高さを表します。

`RevisionHeight`のリセット時(たとえば、Tendermintチェーンをハードフォークする場合)
`RevisionNumber`はインクリメントされます。これにより、IBCクライアントは
チェーンの以前のリビジョン(リビジョン `p`)のブロック高さ` n`と現在のリビジョンのブロック高さ `n`
チェーンのリビジョン(リビジョン `e`)。

同じリビジョン番号を共有する `Height`は、それぞれの` RevisionHeight`を比較するだけで比較できます。
同じリビジョン番号を共有しない `高さ`は、それぞれの `RevisionNumber`を使用してのみ比較されます。
したがって、リビジョン番号が「e + 1」の高さ「h」は、リビジョン番号が「e」の高さ「g」よりも常に大きくなります。
リビジョンの高さの違いに関係なく**。

Ex:

```go
Height{RevisionNumber: 3, RevisionHeight: 0} > Height{RevisionNumber: 2, RevisionHeight: 100000000000}
```

Tendermintチェーンが特定のリビジョンを実行している場合、中継者はリビジョン番号を使用してヘッダーとプルーフを送信するだけです。
チェーンの `chainID`によって与えられ、Tendermintブロックの高さによって与えられるリビジョンの高さ。ハードフォークを使用してチェーンが更新されたとき
ブロックの高さをリセットし、 `chainID`を更新してリビジョン番号をインクリメントします。
次に、IBC Tendermintクライアントは、リビジョン番号を `chainID`と照合し、` RevisionHeight`をTendermintブロックの高さとして扱います。

高さをリセットするアップグレードを超えても永続的なIBC接続を維持するためにリビジョンを使用したいテンダーミントチェーンは、 `chainID`をフォーマットする必要があります
次のように: `{c​​hainID}-{revision_number}`。高さをリセットするアップグレードでは、 `chainID` **をより高いリビジョン番号で更新する必要があります**
前の値より。

元:

-アップグレード前の `chainID`:` gaiamainnet-3`
-アップグレード後の `chainID`:` gaiamainnet-4`

ソロマシンクライアントなど、リビジョンを必要としないクライアントは、リビジョン番号に「0」をハードコードするだけです。
IBCインターフェースを実装するときにIBCの高さを返し、 `RevisionHeight`を排他的に使用する必要があります。

他のクライアントタイプは、独自のロジックを実装して、リレーが `Update`、` Misbehavior`、および
`Verify`はそれぞれ機能します。

IBCインターフェースは `ibcexported.Height`インターフェースを期待しますが、すべてのクライアントはで提供される具体的な実装を使用する必要があります
`02-client/types`と上記で再現。

### [接続](https://github.com/cosmos/ibc-go/blob/main/modules/core/03-connection)

接続は、2つの別々のブロックチェーン上の2つの `ConnectionEnd`オブジェクトをカプセル化します。各
`ConnectionEnd`は、他のブロックチェーン(たとえば、カウンターパーティのブロックチェーン)のクライアントに関連付けられています。
接続ハンドシェイクは、各チェーンのライトクライアントが
それぞれのカウンターパーティを修正します。接続が確立されると、
IBC状態のすべてのクロスチェーン検証を容易にします。接続は、
チャネルの数。

### [証明](https://github.com/cosmos/ibc-go/blob/main/modules/core/23-commitment)および[パス](https://github.com/cosmos/ibc- go/blob/main/modules/core/24-host)
  
IBCでは、ブロックチェーンはネットワークを介して相互にメッセージを直接渡しません。代わりに、
通信する場合、ブロックチェーンは、特別に定義されたパスにいくつかの状態をコミットします。
特定のメッセージタイプと特定の相手方。たとえば、特定のconnectionEndを一部として保存する場合
カウンターパーティチェーン上のモジュールに中継されることを目的としたハンドシェイクまたはパケットの。中継器
プロセスはこれらのパスの更新を監視し、保存されたデータを送信することでメッセージを中継します
パスの下で、カウンターパーティチェーンへの証拠。

証明は、コアIBCからライトクライアントにバイトとして渡されます。これらのバイトを適切に解釈するのは、クライアントの実装次第です。

-すべてのIBC実装がIBCメッセージをコミットするために使用する必要があるパスは、次のように定義されています。
[ICS-24ホストステートマシンの要件](https://github.com/cosmos/ics/tree/master/spec/core/ics-024-host-requirements)。
-すべての実装が生成および検証できる必要がある証明形式は、[ICS-23 Proofs](https://github.com/confio/ics23)実装で定義されています。

### [機能](https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/ocap.md)

IBCは、モジュールが必ずしもそれぞれを信頼するわけではない実行環境で機能することを目的としています。
他の。したがって、IBCは、ポートとチャネルでモジュールアクションを認証して、
適切な権限でそれらを使用できます。

このモジュール認証は、[動的
機能ストア](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-003-dynamic-capability-store.md)。ポートへのバインド時または
モジュールのチャネルを作成すると、IBCはモジュールが要求する必要のある動的機能を返します。
そのポートまたはチャネルを使用するため。動的機能モジュールは、他のモジュールがそのポートまたはチャネルを使用できないようにします。
彼らは適切な能力を持っていません。

この背景情報は役立ちますが、IBCモジュールは相互作用する必要はまったくありません。
これらの低レベルの抽象化。 IBCアプリケーション開発者に関連する抽象化レイヤーは次のとおりです。
チャネルとポートのそれ。 IBCアプリケーションは、自己完結型の**モジュール**として作成する必要があります。

1つのブロックチェーン上のモジュールは、以下を送信することにより、他のブロックチェーン上の他のモジュールと通信できます。
によって一意に識別されるチャネルを介したパケットの受信と確認
`(channelID、portID)`タプル。

有用な例えは、IBCモジュールをインターネットアプリケーションと見なすことです。
コンピュータ。次に、チャネルをIP接続として概念化でき、IBCポートIDは次のようになります。
IPポートに類似しており、IBCchannelIDはIPアドレスに類似しています。したがって、単一の
IBCモジュールのインスタンスは、同じポートで他の任意の数のモジュールと通信でき、
IBCは、(channelID、portIDタプル)を使用して、すべてのパケットを関連するモジュールに正しくルーティングします。アン
IBCモジュールは、複数のポートを介して別のIBCモジュールと通信することもできます。
`(portID <-> portID)`パケットストリームが別の一意のチャネルで送信されています。

### [ポート](https://github.com/cosmos/ibc-go/blob/main/modules/core/05-port)

IBCモジュールは、任意の数のポートにバインドできます。各ポートは、一意の `portID`で識別される必要があります。
IBCは、同じ元帳で動作する相互に信頼できないモジュールで安全になるように設計されているため、
ポートをバインドすると、動的オブジェクト機能が返されます。特定のポートでアクションを実行するため
(たとえば、portIDを持つオープンチャネル)、モジュールは動的オブジェクト機能をIBCに提供する必要があります
ハンドラ。この要件は、悪意のあるモジュールが所有していないポートでチャネルを開くことを防ぎます。したがって、
IBCモジュールは、 `BindPort`で返される機能を要求する責任があります。

### [チャンネル](https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel)

2つのIBCポート間にIBCチャネルを確立できます。現在、ポートは
単一モジュール。 IBCパケットはチャネルを介して送信されます。 IPパケットに宛先IPが含まれているのと同じように
アドレスとIPポート、および送信元IPアドレスと送信元IPポート、IBCパケットには次のものが含まれます
宛先portIDとchannelID、および送信元portIDとchannelID。このパケット構造により、IBCは次のことが可能になります。
モジュールがパケットを受信することを許可しながら、パケットを宛先モジュールに正しくルーティングします。
送信者モジュールを知っています。

チャネルは `ORDERED`にすることができ、送信モジュールからのパケットは
送信された順序でモジュールを受信します。または、チャネルを `UNORDERED`にすることができます。ここで、パケットは
送信モジュールからの送信は、到着した順序で処理されます(送信された順序とは異なる場合があります)。

モジュールは、通信するチャネルを選択できるため、IBCはモジュールが次のことを行うことを期待しています。
チャネルハンドシェイク中に呼び出されるコールバックを実装します。これらのコールバックはカスタムを行うことができます
チャネル初期化ロジック。いずれかのコールバックがエラーを返す場合、チャネルハンドシェイクは失敗します。したがって、
コールバックでエラーを返すと、モジュールはプログラムでチャネルを拒否および受け入れることができます。

チャネルハンドシェイクは4ステップのハンドシェイクです。簡単に言うと、特定のチェーンAが
すでに確立されている接続を使用するチェーンB:

1.チェーンAは `ChanOpenInit`メッセージを送信して、チェーンBでのチャネル初期化の試行を通知します。
2.チェーンBは `ChanOpenTry`メッセージを送信して、チェーンAのチャネルを開こうとします。
3.チェーンAは `ChanOpenAck`メッセージを送信して、チャネルの終了ステータスをオープンとしてマークします。
4.チェーンBは `ChanOpenConfirm`メッセージを送信して、チャネルの終了ステータスをオープンとしてマークします。

すべてのハンドシェイクステップが成功すると、チャネルは両側で開かれます。ハンドシェイクの各ステップで、モジュール
`ChannelEnd`に関連付けられていると、そのコールバックが実行されます。そう
`ChanOpenInit`で、チェーンAのモジュールはそのコールバック` OnChanOpenInit`を実行します。

チャネル識別子は、次の形式で自動導出されます。 `channel- {N}`ここで、Nは次に使用されるシーケンスです。

ポートに動的機能が付属しているように、チャネルの初期化は動的機能を返します
モジュールは、チャネルアクションを認証する機能を渡すことができるように**要求**する必要があります
パケットを送信するようなものです。チャネル機能は、の最初の部分でコールバックに渡されます
ハンドシェーク;初期化チェーンの `OnChanOpenInit`または他のチェーンの` OnChanOpenTry`のいずれか。

#### チャンネルを閉じる

チャネルのクローズは、[ICS 04](https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics)で定義されている2つのハンドシェイクステップで行われます。

`ChanCloseInit`は、チャネルが存在する場合、実行チェーン上のチャネルを閉じます。
すでに閉じられており、その上に存在する接続はOPENです。チャンネルを閉じることができるのは
モジュールを呼び出すか、ORDEREDチャネルでパケットタイムアウトの場合。

`ChanCloseConfirm`は、` ChanCloseInit`を実行しているカウンターパーティチャネルへの応答です。チャンネル
チャネルが存在する場合、実行中のチェーンが閉じますが、チャネルはまだ閉じられていません。
チャネルが存在する接続はOPENであり、実行チェーンは正常に検証します
カウンターパーティチャネルが閉鎖されたこと。


### [パケット](https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel)

モジュールは、IBCチャネルを介してパケットを送信することによって相互に通信します。全て
IBCパケットには、宛先の `portID`と` channelID`が、送信元の `portID`と
`channelID`。このパケット構造により、モジュールは特定のパケットの送信者モジュールを知ることができます。 IBCパケット
オプションで順序付けを強制するシーケンスが含まれています。

IBCパケットには、受信モジュールがパケットを処理する前の期限を決定する `TimeoutHeight`と` TimeoutTimestamp`も含まれています。

モジュールは、IBCパケットの `Data [] byte`フィールド内でカスタムアプリケーションデータを相互に送信します。
したがって、パケットデータはIBCハンドラーに対して不透明です。エンコードするのは送信側モジュールの責任です
アプリケーション固有のパケット情報をパケットの「データ」フィールドに入力します。受信機
モジュールは、その `Data`をデコードして元のアプリケーションデータに戻す必要があります。

### [領収書とタイムアウト](https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel)

IBCは分散ネットワーク上で動作し、潜在的に障害のあるリレーに依存して元帳間でメッセージをリレーするため、
IBCは、パケットがタイムリーに、またはまったく宛先に送信されない場合に対処する必要があります。パケットは
タイムアウトの高さ( `TimeoutHeight`)またはタイムアウトのタイムスタンプ(` TimeoutTimestamp`)にゼロ以外の値を指定すると、宛先チェーンでパケットを正常に受信できなくなります。

-`timeoutHeight`は、宛先チェーンのコンセンサスハイトを示します。その後、パケットは処理されなくなり、代わりにタイムアウトしたものとしてカウントされます。
-`timeoutTimestamp`は、パケットが処理されなくなった後の宛先チェーンのタイムスタンプを示し、代わりにタイムアウトしたものとしてカウントされます。

パケットが正常に受信されずにタイムアウトが経過すると、パケットは受信できなくなります。
宛先チェーンで受信されました。送信モジュールは、パケットをタイムアウトして適切なアクションを実行できます。

タイムアウトに達した場合、パケットタイムアウトの証明を元のチェーンに送信できます。その後、元のチェーンは実行できます
おそらくパケット送信の変更をロールバックすることによって(送信者にロックされた資金を払い戻すなど)、パケットをタイムアウトするアプリケーション固有のロジック。

-ORDEREDチャネルでは、チャネル内の1つのパケットがタイムアウトすると、チャネルが閉じます。

    -パケットシーケンス `n`がタイムアウトした場合、シーケンス` k> n`のパケットは、パケットが送信された順序で処理されるというORDEREDチャネルの契約に違反せずに受信することはできません。
    -ORDEREDチャネルはこの不変条件を適用するため、パケット `n`のタイムアウトを指定してパケット` n`をタイムアウトし、チャネルを閉じるには、シーケンス `n`が宛先チェーンでパケット` n`の指定されたタイムアウトまでに受信されなかったことを証明するだけで十分です。

-UNORDEREDチャネルでは、そのパケットのアプリケーション固有のタイムアウトロジックが適用され、チャネルは閉じられません。

    -パケットは任意の順序で受信できます。

    -IBCは、UNORDEREDチャネルで受信するシーケンスごとにパケット受信を書き込みます。この領収書には情報が含まれていません。これは、UNORDEREDチャネルが指定されたシーケンスでパケットを受信したことを示すことを目的とした単なるマーカーです。

    -UNORDEREDチャネルでパケットをタイムアウトするには、指定されたタイムアウトまでにパケットのシーケンスのパケット受信が**存在しない**ことを証明する必要があります。

このため、ほとんどのモジュールは、そのチャネルのユーザーに対して効果的に機能するために必要な活性保証が少ないため、UNORDEREDチャネルを使用する必要があります。

### [謝辞](https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel)

モジュールは、パケットの処理時にアプリケーション固有の確認応答を書き込むことも選択できます。謝辞を行うことができます:

-モジュールがIBCモジュールからパケットを受信するとすぐに処理する場合は、 `OnRecvPacket`で同期します。
-モジュールがパケットを受信した後のある時点でパケットを処理する場合は非同期。

この確認応答データは、パケット `Data`と同様にIBCに対して不透明であり、IBCによって単純なバイト文字列` [] byte`として扱われます。受信者モジュールは、送信者モジュールが確認応答を正しくデコードできるように、確認応答をエンコードする必要があります。エンコーディングは、チャネルハンドシェイクでのバージョンネゴシエーション中に2者間でネゴシエートする必要があります。

確認応答は、送信者モジュールが適切なアクションを実行できるようにする追加情報とともに、パケット処理が成功したか失敗したかをエンコードできます。

受信チェーンによって確認応答が書き込まれた後、中継器は確認応答を元の送信者モジュールに中継します。

次に、元の送信側モジュールは、確認応答の内容を使用してアプリケーション固有の確認応答ロジックを実行します。

-確認応答が失敗した後、パケット送信の変更をロールバックできます(たとえば、ICS20で送信者に返金します)。

-チェーンの元の送信者で確認応答が正常に受信された後、対応するパケットコミットメントは不要になったため、削除されます。

##その他の読み物と仕様

IBCについて詳しく知りたい場合は、次の仕様を確認してください。

* [IBC仕様の概要](https://github.com/cosmos/ibc/blob/master/README.md)

## 次へ{hide}

IBCをアプリケーションに[統合](./integration.md)する方法について学びます{hide}