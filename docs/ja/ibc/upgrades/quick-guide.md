# IBCチェーンとそのクライアントをアップグレードする方法

チェーンとカウンターパーティのクライアントをアップグレードする方法を学びます。 {synopsis}

チェーンをアップグレードするためのこのドキュメントの情報は、SDKチェーンに関連しています。ただし、カウンターパーティクライアント向けのガイドは、アップグレードを可能にするすべてのTendermintクライアントに関連しています。

### IBCクライアントの最新のアップグレード

IBCに接続されたチェーンは、アップグレードによってカウンターパーティのIBCクライアントが破損する場合、IBCアップグレードを実行する必要があります。現在のIBCプロトコルは、IBCクライアントを壊すアップグレードの特定のサブセットのテンダーミントチェーンのアップグレードをサポートしています。これは、IBCクライアントを壊すアップグレードの完全なリストと、IBCプロトコルが現在そのようなアップグレードをサポートしているかどうかです。

IBCは現在、計画外のアップグレードを**サポートしていません**。カウンターパーティクライアントが安全に接続を維持できるように、以下のすべてのアップグレードは、アップグレードチェーンによって事前に計画され、コミットされる必要があります。

注:アップグレードはTendermintクライアントに対してのみ実装されるため、このドキュメントでは、カウンターパーティのIBCTendermintクライアントを破壊するTendermintチェーンのアップグレードについてのみ説明します。

1.チェーンIDの変更:**サポート**
2. UnbondingPeriodの変更:**部分的にサポート**されているため、チェーンは問題なくUnbonding期間を延長できます。ただし、非結合期間を短縮すると、一部のカウンターパーティクライアントが不可逆的に破損する可能性があります。したがって、チェーンが非結合期間を短縮することは**推奨されません**。
3.高さの変更(0にリセット):チェーンがチェーンIDのリビジョン番号をインクリメントすることを覚えている限り、**サポート**。
4. ProofSpecsの変更:**サポート**。アップグレード全体でIBCプルーフを検証するために必要なプルーフ構造が変更された場合は、これを変更する必要があります。例:IAVLストアからSimpleTreeストアへの切り替え
5. UpgradePathの変更:**サポート**。これには、アップグレードされたクライアントとコンセンサス状態がアップグレードストアに保存されるキーの変更、またはアップグレードストア自体の移行が含まれる場合があります。
6. IBCストアの移行:IBCストアの場所は接続によってネゴシエートされるため、**サポートされていません**。
7.下位互換性のあるバージョンのIBCへのアップグレード:サポート
8. IBCの下位互換性のないバージョンへのアップグレード:IBCバージョンは接続ハンドシェイクでネゴシエートされるため、**サポートされていません**。
9. Tendermint LightClientアルゴリズムの変更:**部分的にサポートされています**。カウンターパーティも新しいライトクライアントアルゴリズムをサポートするようにアップグレードされている場合、ClientStateまたはConsensusState構造体を変更しないライトクライアントアルゴリズムへの変更がサポートされる場合があります。 ClientStateおよびConsensusState構造体自体の更新を必要とする変更は、古いClientState構造体を新しいClientState構造体に変換するパスを提供することで理論的に可能です。ただし、これは現在実装されていません。

### SDKチェーンのステップバイステップのアップグレードプロセス

IBC接続チェーンがカウンターパーティクライアントを破壊するアップグレードを実行している場合、カウンターパーティクライアントが破壊されないように、アップグレードが最初に上記のリストを使用してIBCによってサポートされていることを確認してから、以下に説明するアップグレードプロセスを実行する必要があります。

1. `UpgradePlan`と`UpgradedClientState`フィールドの新しいIBCClientState。 `UpgradePlan`はアップグレードの高さを**のみ**(アップグレード時間なし)指定する必要があり、` ClientState`にはすべての有効なクライアントに共通のフィールドのみを含め、クライアントがカスタマイズ可能なフィールド(TrustingPeriodなど)をゼロにする必要があることに注意してください。 。
2.投票して、 `UpgradeProposal`に合格します

`UpgradeProposal`が渡されると、アップグレードモジュールはキーの下でUpgradedClientをコミットします:` upgrade/UpgradedIBCState/{upgradeHeight}/upgradedClient`。アップグレードの高さの直前のブロックで、アップグレードモジュールは、キーの下にある次のチェーンの初期コンセンサス状態もコミットします: `upgrade/UpgradedIBCState/{upgradeHeight}/upgradedConsState`。

チェーンがアップグレードの高さに達して停止すると、リレーはカウンターパーティクライアントを古いチェーンの最後のブロックにアップグレードできます。次に、この最後のブロックに対して `UpgradedClient`と` UpgradedConsensusState`の証明を提出し、カウンターパーティクライアントをアップグレードできます。

### 中継者がカウンターパーティクライアントをアップグレードするための段階的なアップグレードプロセス

アップグレードチェーンがアップグレードを確約すると、リレーは、チェーンがアップグレードの高さで停止するまで待ってから、カウンターパーティクライアントをアップグレードする必要があります。これは、チェーンがアップグレードプランを実行する前にスケジュールを変更したりキャンセルしたりする可能性があるためです。したがって、リレーは、チェーンがアップグレードの高さに達して停止するまで待ってから、アップグレードが確実に行われるようにする必要があります。

したがって、カウンターパーティクライアントをアップグレードしようとするリレーのアップグレードプロセスは次のとおりです。

1.アップグレードチェーンがアップグレードの高さに達するのを待ち、停止します
2.古いチェーンの最後の高さで `UpgradedClient`と` UpgradedConsensusState`の証明について完全なノードをクエリします。
3. `UpdateClient`メッセージを使用して、カウンターパーティクライアントを古いチェーンの最後の高さに更新します。
4. `UpgradeClient`、` UpgradedConsensusState`およびそれぞれの証明を使用して `UpgradeClient`メッセージをカウンターパーティチェーンに送信します。
5.新しいアップグレードされたチェーンからのヘッダーを使用して `UpdateClient`メッセージをカウンターパーティチェーンに送信します。

カウンターパーティチェーンのTendermintクライアントは、アップグレードチェーンが実際にアップグレードされたクライアントとアップグレードされたコンセンサス状態にアップグレードされた高さでコミットしたことを確認します(アップグレードの高さはキーに含まれているため)。プルーフがアップグレードの高さに対して検証された場合、クライアントは、クライアントがカスタマイズしたすべてのフィールドを保持したまま、新しいクライアントにアップグレードします。したがって、古いTrustingPeriod、TrustLevel、MaxClockDriftなどが保持されます。 UnbondingPeriod、ChainId、UpgradePathなどの新しいチェーン指定フィールドを採用している間。注:新しいチェーン選択フィールドを指定すると、古いクライアント選択フィールドが無効になる可能性があるため、これにより無効なクライアントが発生する可能性があります。チェーンをアップグレードする場合は、古いクライアントを壊す可能性のあるパラメーターを変更しないことで、これらの状況を回避するようにしてください。例については、サポートされているアップグレードセクションのUnbondingPeriodの例を参照してください。

アップグレードされたコンセンサス状態は、純粋に将来の `UpdateClientMsgs`の信頼の基礎として機能し、証明の検証を実行するためのコンセンサスルートは含まれません。したがって、中継者は、接続を再度証明検証に使用できるように、新しいチェーンからのヘッダーを含む `UpdateClientMsg`を送信する必要があります。